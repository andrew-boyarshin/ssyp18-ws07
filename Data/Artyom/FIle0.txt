рефикс-функция. Алгоритм Кнута-Морриса-Пратта
Префикс-функция. Определение
Дана строка s[0 \ldots n-1]. Требуется вычислить для неё префикс-функцию, т.е. массив чисел \pi[0 \ldots n-1], где \pi[i] определяется следующим образом: это такая наибольшая длина наибольшего собственного суффикса подстроки s[0 \ldots i], совпадающего с её префиксом (собственный суффикс — значит не совпадающий со всей строкой). В частности, значение \pi[0] полагается равным нулю.

Математически определение префикс-функции можно записать следующим образом:

 \pi[i] = \max_{k=0 \ldots i} ~ \{ ~ k ~ : ~ s[0 \[...]

Например, для строки "abcabcd" префикс-функция равна: [0, 0, 0, 1, 2, 3, 0], что означает:

у строки "a" нет нетривиального префикса, совпадающего с суффиксом;
у строки "ab" нет нетривиального префикса, совпадающего с суффиксом;
у строки "abc" нет нетривиального префикса, совпадающего с суффиксом;
у строки "abca" префикс длины 1 совпадает с суффиксом;
у строки "abcab" префикс длины 2 совпадает с суффиксом;
у строки "abcabc" префикс длины 3 совпадает с суффиксом;
у строки "abcabcd" нет нетривиального префикса, совпадающего с суффиксом.
Другой пример — для строки "aabaaab" она равна: [0, 1, 0, 1, 2, 2, 3].

Тривиальный алгоритм
Непосредственно следуя определению, можно написать такой алгоритм вычисления префикс-функции:

vector<int> prefix_function (string s) {
	int n = (int) s.length();
	vector<int> pi (n);
	for (int i=0; i<n; ++i)
		for (int k=0; k<=i; ++k)
			if (s.substr(0,k) == s.substr(i-k+1,k))
				pi[i] = k;
	return pi;
}
Как нетрудно заметить, работать он будет за O(n^3), что слишком медленно.

Эффективный алгоритм
Этот алгоритм был разработан Кнутом (Knuth) и Праттом (Pratt) и независимо от них Моррисом (Morris) в 1977 г. (как основной элемент для алгоритма поиска подстроки в строке).

Первая оптимизация
Первое важное замечание — что значение \pi[i+1] не более чем на единицу превосходит значение \pi[i] для любого i.

Действительно, в противном случае, если бы \pi[i+1] > \pi[i] + 1, то рассмотрим этот суффикс, оканчивающийся в позиции i+1 и имеющий длину \pi[i+1] — удалив из него последний символ, мы получим суффикс, оканчивающийся в позиции i и имеющий длину \pi[i+1]-1, что лучше \pi[i], т.е. пришли к противоречию. Иллюстрация этого противоречия (в этом примере \pi[i-1] должно быть равно 3):

 \underbrace{ \overbrace{s_0 \ s_1}^{\pi[i-1]=2} \[...]

(на этой схеме верхние фигурные скобки обозначают две одинаковые подстроки длины 2, нижние фигурные скобки — две одинаковые подстроки длины 4)

Таким образом, при переходе к следующей позиции очередной элемент префикс-функции мог либо увеличиться на единицу, либо не измениться, либо уменьшиться на какую-либо величину. Уже этот факт позволяет нам снизить асимптотику до O(n^2) — поскольку за один шаг значение могло вырасти максимум на единицу, то суммарно для всей строки могло произойти максимум n увеличений на единицу, и, как следствие (т.к. значение никогда не могло стать меньше нуля), максимум n уменьшений. В итоге получится O(n) сравнений строк, т.е. мы уже достигли асимптотики O(n^2).

Вторая оптимизация
Пойдём дальше — избавимся от явных сравнений подстрок. Для этого постараемся максимально использовать информацию, вычисленную на предыдущих шагах.

Итак, пусть мы вычислили значение префикс-функции \pi[i] для некоторого i. Теперь, если s[i+1] = s[\pi[i]], то мы можем с уверенностью сказать, что \pi[i+1] = \pi[i] + 1, это иллюстрирует схема:

 \underbrace{ \overbrace{s_0 \ s_1 \ s_2}^{\pi[i]}[...]

(на этой схеме снова одинаковые фигурные скобки обозначают одинаковые подстроки)

Пусть теперь, наоборот, оказалось, что s[i+1] \ne s[\pi[i]]. Тогда нам надо попытаться попробовать подстроку меньшей длины. В целях оптимизации хотелось бы сразу перейти к такой (наибольшей) длине j < \pi[i], что по-прежнему выполняется префикс-свойство в позиции i, т.е. s[0 \ldots j-1] = s[i-j+1 \ldots i]:

 \overbrace{\underbrace{s_0 \ s_1}_{j} \ s_2 \ s_3[...]

Действительно, когда мы найдём такую длину j, то нам будет снова достаточно сравнить символы s[i+1] и s[j] — если они совпадут, то можно утверждать, что \pi[i+1] = j+1. Иначе нам надо будет снова найти меньшее (следующее по величине) значение j, для которого выполняется префикс-свойство, и так далее. Может случиться, что такие значения j кончатся — это происходит, когда j=0. В этом случае, если s[i+1]=s[0], то \pi[i+1]=1, иначе \pi[i+1]=0.

Итак, общая схема алгоритма у нас уже есть, нерешённым остался только вопрос об эффективном нахождении таких длин j. Поставим этот вопрос формально: по текущей длине j и позиции i (для которых выполняется префикс-свойство, т.е. s[0 \ldots j-1] = s[i-j+1 \ldots i]) требуется найти наибольшее k < j, для которого по-прежнему выполняется префикс-свойство:

 \overbrace{\underbrace{s_0 \ s_1}_{k} \ s_2 \ s_3[...]

После столь подробного описания уже практически напрашивается, что это значение k есть не что иное, как значение префикс-функции \pi[j-1], которое уже было вычислено нами ранее (вычитание единицы появляется из-за 0-индексации строк). Таким образом, находить эти длины k мы можем за O(1) каждую.

Итоговый алгоритм
Итак, мы окончательно построили алгоритм, который не содержит явных сравнений строк и выполняет O(n) действий.

Приведём здесь итоговую схему алгоритма:

Считать значения префикс-функции \pi[i] будем по очереди: от i=1 к i=n-1 (значение \pi[0] просто присвоим равным нулю).
Для подсчёта текущего значения \pi[i] мы заводим переменную j, обозначающую длину текущего рассматриваемого образца. Изначально j = \pi[i-1].
Тестируем образец длины j, для чего сравниваем символы s[j] и s[i]. Если они совпадают — то полагаем \pi[i] = j+1 и переходим к следующему индексу i+1. Если же символы отличаются, то уменьшаем длину j, полагая её равной \pi[j-1], и повторяем этот шаг алгоритма с начала.
Если мы дошли до длины j=0 и так и не нашли совпадения, то останавливаем процесс перебора образцов и полагаем \pi[i] = 0 и переходим к следующему индексу i+1.